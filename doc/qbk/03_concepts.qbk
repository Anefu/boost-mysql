[/
    Copyright (c) 2019-2022 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:concepts Concepts]
[nochunk]

Purpose: briefly explain the library main classes and functions, and how to use them.
Links to specialized sections for further details.

Connection: the main entry point. Stream-templated I/O object that contains an actual Stream.
connect/close, query, prepare_statement.

resultset: proxy I/O object that represents the result of a query execution.
Contains metadata (call meta()) and state about the operation. Doesn't contain the actual rows.
Call read_xxx() to get them.

statement: proxy I/O object representing a server-side prepared statement. Main purpose is calling execute(),
which yields a resultset.

In all cases, communication will happen over the Stream contained in connection, even if the operation
is called on resultset or statement. Relevant for lifetimes and threading.

query() gets passed a textual SQL string and "returns" a resultset. No safe string escaping right now.
Use only for queries known ahead of time, e.g. "START TRANSACTION", "SET NAMES utf8", etc.

prepare_statement() gets passed a textual SQL string with placeholders and "returns" a statement object.
Statement objects are proxy I/O objects (reference the connection). Main purpose is calling execute(),
passing as many params as required.

After getting a resultset, call read_xxx() to read the actual rows into memory (into row, rows, etc. - more on that later).
When the resultset has no more rows, we say it's complete(). For complete resultsets, you can access extra info, like last_insert_id.
Background: calling query() or execute() sends the request and reads the initial response, but not the rows. But the server has sent them,
so we need to read them before moving to the next operation. last_insert_id & co come in an EOF packet marking end of rows, complete() signals
that we've received it and it's safe to engage in the next operation.

When calling read_xxx(), you get some combination of row, rows, etc. There are
    rows    rows_view
    row     row_view
    field   field_view

field and field_view: the smallest unit of data; a single "cell" in a MySQL table. Variant-like types
that can represent any type MySQL will return. field is owning, regular value that may allocate.
field_view is a lightweight variation of field that may point to external memory (usually memory allocated by a row).

row: owning, regular, vector-like collection of fields. Element type: field_view, valid as long as the memory allocated by row valid.
row_view: reference type for row; non-allocating; constructed from a row or rows object; valid as long as the memory allocated by the row is valid.
rows: owning, regular, matrix-like collection of fields. Represents several rows in an optimized way. Indexing it yields a row_view
rows_view: reference type for rows; same applies

All row types are read-only; designed for memory re-use. If you need to modify them, copy to a separate collection of fields (e.g. to_vector())

Several row-reading functions
    read_one, row       read_one, row_view
    read_some, rows     read_some, rows_view
    read_all, rows      read_all, rows_view

read_one read one row at a time.
read_some will read at least one, and as much as possible whithout allocating extra buffer space.
read_all will read the entire resultset
The non-owning functions may be faster, as they make less copies when the fields are strings. The returned rows are valid until the next network operation on the stream is called.

Prefer owning functions if super efficiency is not key. Non-owning functions may be faster because they
tend to allocate memory, but 1) know what you're doing 2) not suitable for "process while reading next batch"

Use read_one when you can/need to process one row at a time, or when the resultset is too big to fit in memory
Use read_all as the default for small resultsets that can fit in memory
Use read_some when you need maximum efficiency, in exchange for more complexity. Fine tune buffer sizes before going down that path

Async: there are sync with err, exc, async and async with error_info. All operations may imply reads, writes, or both.
You can't call operations that imply reads and writes concurrently. At the moment, most ops are both, so one async at a time.
All operations end up modifying the Stream state, so not thread-safe, use strands.

Encoding: set it on handshake or with SET NAMES and everything you send/receive will be in this encoding.
We don't do any handling.

Streams: the most used tcp_ssl_connection, unix_ssl_connection. But you can always define your own by using connection
(e.g. other executors, default completion tokens). connect() and close() handle the physical level; you may handle
it yourself and use handshake() and quit(). When calling connect() you can pass credentials, default db, buffer sizes and SSL mode. (?)

Error recovery: after any server error, you can still use the connection. After a client or network error, close/reopen. In the common case
of ssl streams, delete the object and create it again.

[endsect]
