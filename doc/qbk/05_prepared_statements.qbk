[/
    Copyright (c) 2019-2022 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:prepared_statements Prepared statements]

[import ../../example/prepared_statements.cpp]

This section covers using [mysqllink sql-prepared-statements.html
server-side prepared statements]. The functionality is broadly
similar to the `PREPARE`, `EXECUTE` and `DEALLOCATE`
SQL commands. However, note that the functions and classes
here described are [*not based on SQL query composition],
but make use of dedicated protocol functionality.
This makes using this API preferable to using query composition
in terms of security and efficiency.

The rest of this section contains a detailed explanation of
prepared statement mechanics, together with some code
snippets. You can find the full code listing
[link mysql.examples.prepared_statements here].

[heading Preparing a statement]

To prepare a statement, call [refmem connection prepare_statement]
or [refmem connection async_prepare_statement]. You must pass in
a string containing the text of the SQL statement (similar
to how [link mysql.queries text queries] work). These functions
return a [reflink statement] object.

In addition to regular SQL, you can also use 
question mark characters (`?`) to represent parameters 
(as described [mysqllink prepare.html here]).
When you execute the statement (next section), you
provide values for each of the parameters you declared.
You don't need to escape or sanitize these values anyhow,
thus avoiding the possibility of SQL injection attacks.

The following prepares a statement with one
parameter (`conn` is a [reflink tcp_ssl_connection]):

[prepared_statements_prepare]

[include helpers/query_strings_encoding.qbk]

[heading Executing a statement]

To execute a statement, use [refmem statement execute] or [refmem statement async_execute].
Executing a statement yields a [reflink resultset].

When executing a statement, you must pass in [*exactly as many parameters
as the statement has]. Failing to do so will result in an error.
Parameters are passed as a `std::tuple`, and in the same order as they
appear in the statement text. You can pass in built-in integers,
`float`, `double`, [reflink date], [reflink datetime], [reflink time],
[reflink field_view] and [reflink field] objects as parameters,
with the expected results. You can use `nullptr` objects to represent `NULL`
parameters. If your statement doesn't have any parameters, use the
[reflink no_statement_params] variable.

The following executes the statement we prepared in the previous
section, binding the `first_name` parameter to `"Efficient"`:

[prepared_statements_execute]

Note that MySQL is pretty flexible and will perform casting to try to match
the supplied value to the required type, depending on the context.

In particular, for integer types, conversions to narrower integer types
will take place as long as the supplied value is in range. For example:

```
    // Table created using: CREATE TABLE my_table (field_int TINYINT)
    tcp_ssl_statement stmt;
    conn.prepare_statement("INSERT INTO my_table (field_int) VALUES (?)", stmt);

    tcp_ssl_resultset result;
    std::int64_t value = 42; // OK, in range
    stmt.execute(std::make_tuple(value), result);

    value = 0xffff; // Oops, out of range
    stmt.execute(std::make_tuple(value), result); // will throw
```

To insert a `NULL` value, use the following:

```
    stmt.execute(std::make_tuple(nullptr), result);
```

For a full reference on the types you can pass as parameters when
executing a statement, see [link mysql.fields.cpp_to_mysql this section].

[heading Multi-function operation]

When you call [refmem statement execute], you start a "multi-function" operation.
`execute()` will send the execute request to the server. The server then sends an initial response
and all the generated rows. `execute()` will just read the initial response, and not the rows.

After a successful `execute()`, [*you must read all the generated rows] by calling any of the `read_xxx`
functions on `resultset`. If you start any other operation involving a read before doing this,
you will get undefined results.

[heading Closing a statement]

Prepared statements are created server-side, and
thus consume server resources. If you don't need a 
[reflink statement] anymore, you can call
[refmem statement close] or
[refmem statement async_close] to instruct
the server to deallocate it.

Prepared statements are managed by the server on a
per-connection basis. Once you close your connection
with the server, all prepared statements you have
created using this connection will be automatically
deallocated.

If you are creating your prepared statements at the beginning
of your program and keeping them alive until the connection
is closed, then there is no need to call [refmem
statement close], as closing the connection will do the cleanup
for you. If you are creating and destroying prepared statements
dynamically, then it is advised to use [refmem
statement close] to prevent excessive resource usage in the server.

Finally, note that [reflink statement]'s destructor
does not perform any server-side deallocation of the statement.
This is because closing a statement involves a network
operation that may block your code or fail.

[endsect]