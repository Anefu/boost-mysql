[/
    Copyright (c) 2019-2022 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:async Going async]
[nochunk]

Following __Asio__'s convetion, all network operations have
asynchronous versions with the same name prefixed by `async_`.
The last parameter to async operations is a __CompletionToken__,
which dictates how the asynchronous operation will be managed
and the function's return type. These `async_` functions are
called async initiating functions.

Every async initiating function has an associated
handler type, which dictates how the asynchronous operation
communicates its result back to the caller. This handler
type always has one of the two folling forms:

# `void(error_code)`. Used in operations that do
   not have a proper result, e.g. [refmem connection async_connect].
# `void(error_code, T)`. Used in operations that
   have a result, e.g. [refmem resultset async_read_one]
   (in this case, `T` is `bool` for the "owning" version).
   
As noted [link mysql.error_handling here], all asynchronous
are overloaded to accept an optional [reflink error_info]
output parameter, which is set before calling the
completion handler, and is populated with diagnostic
information, if available.

[section:reads_writes Stream reads and writes]

As mentioned in [link mysql.overview.async this section], only a single read and a single
write operation per connection can be outstanding at a given point in time.
If you need to perform queries in parallel, open more connections to the server.

[endsect]

[section:proxy_io Proxy I/O objects]

[reflink resultset] and [reflink statement] are proxy I/O objects. This means
that they don't own a separate `Stream` object, but rather rely on an underlying
[reflink connection] to perform I/O. This has the following implications:

* To use a `resultset` or a `statement` for operations that involve I/O, the
  `connection` object that created them must be alive and open.
* Read and write operations on these objects count towards the limit of
  one concurrent read and write operation per connection.
* I/O operations on these objects end up mutating the underlying `connection`'s
  state. In a multi-threaded environment, appropriate guards must be in place
  to avoid race conditions. This applies among all proxy I/O objects for a single connection;
  different connections share no state.

[endsect]

[section:ops Protocol operations]

The MySQL protocol is a half-duplex request/reply protocol that has the concept of "operations".
This library models some operations as single functions (e.g. [refmem connection prepare_statement]),
and splits other operations into several calls (e.g. [refmem connection query] +
[refmem resultset read_all]), to provide more flexibility.

Once you engage in a multi-function operation, you must
complete it (e.g. by calling `resultset::read_xxx` until all rows have been read) before engaging
into the next one. Failing to do so will produce network packet mismatches, resulting in
undefined behavior.

[endsect]


[section:completion_tokens Completion tokens]

Any completion token you may use with Boost.Asio can also be used
with this library. Here are some of the most common:

* [*Callbacks]. You can pass in a callable (function pointer,
  function object) with the same signature as the handler
  signature specified for the operation. The handler
  will be called when the operation completes. The initiating
  function will return `void`.
  
  [link mysql.examples.query_async_callbacks This example]
  demonstrates asynchronous text queries with callbacks.
* [*Futures]. In this case, you pass in the constant
  [asioreflink use_future use_future] as completion token.
  The initiating function will return one of the following:
    * `std::future<void>`, if the completion handler has the
      form given by 1).
    * `std::future<T>`, if the completion handler has the
      form given by 2).
  
  You can wait for the future by calling `future::get`.
  If an error occurs, `future::get` will throw an exception.
  Note that the exception will [*not] contain the extra information
  stored in the [reflink error_info].
  
  [link mysql.examples.query_async_futures This example]
  demonstrates using futures with async queries.
* [*__Coroutine__ coroutines]. In this case, you pass in
  a [asioreflink yield_context yield_context]. To obtain one
  of these, you should use [asioreflink spawn spawn] to create
  a new coroutine. The initiating function will return:
    * `void`, if the completion handler has the
      form given by 1).
    * `T`, if the completion handler has the
      form given by 2).
  
  If you use [asioreflink basic_yield_context/operator_lb__rb_
  yield_context::operator\[\]], the operation will set the
  given [reflink error_code] when it fails. Otherwise, the
  function will throw a exception. Note that this exception
  will not contain the extra information stored in the
  [reflink error_info].
  
  [link mysql.examples.query_async_coroutines This example]
  uses __Coroutine__ coroutines with async queries.
* [*C++20 coroutines]. In this case, you pass in the constant
  [asioreflink use_awaitable use_awaitable] as completion token.
  The initiating function will return:
    * [^[asioreflink awaitable awaitable<void>]],
      if the completion handler has the form given by 1).
    * [^[asioreflink awaitable awaitable<T>]],
      if the completion handler has the form given by 2).
  
  You can then use `co_await` on this return value. If the
  operation fails, `co_await` will throw an exception.
  Note that this exception will not contain the extra
  information stored in the [reflink error_info].
  
  [link mysql.examples.query_async_coroutinescpp20 This example]
  demonstrates using C++20 coroutines to perform text
  queries.
* Any other type that satisfies the __CompletionToken__ type requirements.
  We have listed the most common ones here, but you can craft your own
  and use it with this library's async operations.
  
[endsect]

[section:default_completion_tokens Default completion tokens]
  
__Self__ also supports default completion tokens. Recall that
some stream types may have an associated __Executor__ that
has an associated default completion token type (see
[asiorelink default_completion_token default_completion_token]).
If this is the case, you don't need to specify the
__CompletionToken__ parameter in initiating functions,
and the default will be used.
[link mysql.examples.default_completion_tokens This example]
demonstrates using default completion tokens with __Self__.

[endsect]

[section:cancellations_and_timeouts Cancellations and timeouts]

All async operations in this library support
[@boost:/doc/html/boost_asio/overview/core/cancellation.html per-operation cancellation].
All operations support only the `terminal` [asioreflink cancellation_type cancellation_type].
This means that, if an async operation is cancelled, the [reflink connection] object
is left in an unspecified state, after which you should close or destroy the connection.
In particular, it is [*not] safe to retry the cancelled operation.

Supporting cancellation allows you to implement timeouts without explicit
support from the library. [link mysql.examples.timeouts This example]
demonstrates how to implement this pattern.

Note that cancellation happens at the Boost.Asio level, and not at the
MySQL operation level. This means that, when cancelling an operation, the
current network read or write will be cancelled. The operation may have
already reached the server and be executed. As stated above, after an
operation is cancelled, the connection is left in an unspecified state, and
you should close or destroy it.

[endsect]

[endsect] [/ async]
