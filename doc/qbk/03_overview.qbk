[/
    Copyright (c) 2019-2022 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:overview Overview]
[nochunk]

This section briefly explains the library main classes and functions, and how to use them.
The following diagram shows the interaction between the main classes in the library:

[$mysql/images/class_hierarchy.svg [align center]]

[section:connection Connection objects]

[reflink connection] is the library's "entry point". A connection is an I/O object, templated on
a [reflink Stream] type. A `connection` contains an instance of that `Stream` type and additional state required
by the protocol. To create a `connection`, pass to its constructor the arguments required to construct a `Stream`.

The library defines some typedefs to make things less verbose. The most common one is [reflink tcp_ssl_connection].
In this case, `Stream` is `boost::asio::ssl::stream<boost::asio::ip::tcp::socket>`,
which can be constructed from a `io_context::executor_type` and a `ssl::context`:

```
    boost::asio::io_context ctx;
    boost::asio::ssl::context ssl_ctx(boost::asio::ssl::context::tls_client);
    boost::mysql::tcp_ssl_connection conn(ctx.get_executor(), ssl_ctx);
```

Typedefs for other transports are also available. See [link mysql.other_streams this section] for more info.

The MySQL client/server protocol is session-oriented. Before anything else, you must perform session
establishment, usually by calling [refmem connection connect]. We've already gone through this in the
[link mysql.tutorial tutorial], so we won't repeat it here.

[endsect]

[section:queries_stmts Text queries and prepared statements]

The two main ways to use a connection are text queries and prepared statements:

[table
    [
        [Feature]
        [Used for...]
        [Code]
    ]
    [
        [
            Text queries: [refmem connection query].
        ]
        [
            Simple queries, without parameters:

                * `"START TRANSACTION"`
                * `"SET NAMES utf8"`
                * `"SHOW TABLES"`
            
        ]
        [
            ```
            tcp_ssl_resultset result;
            conn.query("START TRANSACTION", result);
            ```
        ]
    ]
    [
        [
            Prepared statements: [refmem connection prepare_statement], [refmem statement execute].
        ]
        [
            Queries with parameters unknown at compile-time.
        ]
        [
            ```
            tcp_ssl_connection conn;
            conn.connect(/* server host, password... */);

            tcp_ssl_statement stmt;
            conn.prepare_statement("SELECT first_name FROM employees WHERE company_id = ? AND salary > ?");

            tcp_ssl_resultset result;
            stmt.execute(std::make_tuple("HGS", 30000), result);
            ```
        ]
    ]
]

[reflink tcp_ssl_resultset] is a helper typedef for [reflink resultset]. Resultset objects
represent the result of a query or statement execution. They hold auxiliar information
about the operation, but don't contain the actual data generated by the operation.
The next sections show how to obtain it.

[reflink tcp_ssl_statement] is a helper typedef for [reflink statement], which represent
server-side prepared statements, as we've seen.

[endsect]

[section:rows_fields Rows and fields]

Values retrieved from SQL queries are represented as variant-like objects called fields.
Fields are organized in rows. This library defines the following types to represent fields and rows:

[variablelist
    [
        [[reflink field]]
        [The smallest unit of data. A single "cell" in a MySQL table. This is an owning, variant-like type.]
    ]
    [
        [[reflink field_view]]
        [Like `field`, but non-owning.]
    ]
    [
        [[reflink row]]
        [An owning, `vector`-like collection of fields.]
    ]
    [
        [[reflink row_view]]
        [Like `row`, but non-owning.]
    ]
    [
        [[reflink rows]]
        [An owning, matrix-like collection of fields. Represents several rows of the same size in an optimized way.]
    ]
    [
        [[reflink rows_view]]
        [Like `rows`, but non-owning.]
    ]
]

[endsect]

[section:read Reading rows]

There are three methods to read rows from a `resultset`:

[variablelist
    [
        [[refmem resultset read_one]]
        [Reads rows one by one.]
    ]
    [
        [[refmem resultset read_all]]
        [Reads all rows at once.]
    ]
    [
        [[refmem resultset read_some]]
        [Reads rows in batches of unspecified size.]
    ]
]

For each method, there is an "owning" version, which populates [reflink row] or [reflink rows]
objects by lvalue reference; and a "non-owning" version, which returns [reflink row_view]
or [reflink rows_view] objects, pointing to the `connection` internal buffers.
These view objects are valid until you perform the next operation involving network
transfers on the connection.

The following table shows the most used methods. For a full reference, see
[link mysql.resultsets.read this section].

[table
    [
        [Function]
        [Typical use]
        [Use when...]
    ]
    [
        [
            [refmem resultset read_one], owning
        ]
        [
            ```
            row r;
            while (result.read_one(r))
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * [*By default], for resultsets of arbitrary size.
            * When processing one row at a time is preferred.
            * A good alternative to [refmem resultset read_all], when all rows may not fit in memory.
        ]
    ]
    [
        [
            [refmem resultset read_all], owning
        ]
        [
            ```
            rows all_rows;
            result.read_all(all_rows);
            for (row_view r: all_rows)
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * [*By default], for small resultsets.
            * When having all rows at the same time in memory is advantageous.
        ]
    ]
    [
        [
            [refmem resultset read_some], non-owning
        ]
        [
            ```
            while (!result.complete())
            {
                rows_view row_batch = result.read_some(use_views);

                for (row_view r: row_batch)
                {
                    // Process r as required
                    std::cout << r << std::endl;
                }
            }
            ```
        ]
        [
            * [*By default], when efficiency is key.
            * There will be no server interaction that may invalidate the view while you process it.
        ]
    ]
]

In the above snippets, we use [refmem resultset complete] to check whether there are more rows or not.
We say a `resultset` is complete when there are no more rows to read. The server indicates this by sending
us a special packet ("EOF packet" in MySQL slang). After a `resultset` is `complete`, you can access some
additional information about the query execution, like [refmem resultset last_insert_id]
and [refmem resultset affected_rows].

[warning
    Once you call `connection::query` or `statement::execute`, the server immediately sends all rows to the client.
    [*You must read all rows], until the resultset is `complete`, before engaging in further operations.
    Otherwise, the results are undefined.
]

[endsect]

[section Using rows and fields]

All row types support random access iterators, as well as `at()` and `operator[]` with the usual semantics.

When iterating or indexing a [reflink row] object, you obtain a [reflink field_view], which is an object
with reference semantics, pointing into `row`'s storage. You can "persist" a `field_view` by constructing a
[reflink field] from it.

```
    tcp_ssl_resultset result;
    row r;

    conn.query("SELECT \"abc\", 42", result);
    result.read_one(r);
    field_view ref = r[0]; // ref points to the string "abc", references r
    field f (ref); // f contains the string "abc"
```

Indexing or iterating a `row_view` also yields `field_view`s. Similarly, indexing
or iterating [reflink rows] or [reflink rows_view] objects yields a `row_view`.

[h4 Using fields]

Both `field` and `field_view` are specialized variant-like types that can hold any type
you may find in a MySQL table. The following accessor operations are supported:

* You can query a field's type by using [reflink2 field_view.kind kind],
  which returns a [reflink field_kind] enum. You can query whether a field.
* You can query whether a field contains a certain type with `field::is_xxx`.
* You can get the underlying value with `field::as_xxx` and `field::get_xxx`.
  The `as_xxx` functions are checked (they will throw an exception if the
  actual type doesn't match), while the `get_xxx` are unchecked (they result
  in undefined behavior on type mismatch).
* You can stream and compare fields for equality.

Some examples:

```
    tcp_ssl_resultset result;
    row r;

    conn.query("SELECT \"abc\", 42", result);
    result.read_one(r);

    field_view f = r[0]; // ref points to the string "abc", references r
    if (f.is_string())
    {
        // we know it's a string, unchecked access
        boost::string_view s = f.get_string();
        std::cout << s << std::endl;
    }
    else
    {
        // Oops, something went wrong - schema msimatch?
    }

    // Checked access. Throws if f doesn't contain an int
    f = r[1];
    std::int64_t value = f.as_int64();
    std::cout << value << std::endl;
```

The following table shows the mapping from MySQL types to C++ types:

[table
    [
        [`field_kind`]
        [C++ type]
        [MySQL types]
        [`is` accessor]
        [`as` accessor]
        [`get` accessor]
    ]
    [
        [`int64`]
        [`std::int64_t`]
        [Signed `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`, `YEAR`, `BIT`]
        [[refmemunq field_view is_int64]]
        [[refmemunq field_view as_int64]]
        [[refmemunq field_view get_int64]]
    ]
    [
        [`uint64`]
        [`std::uint64_t`]
        [Unsigned `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`]
        [[refmemunq field_view is_uint64]]
        [[refmemunq field_view as_uint64]]
        [[refmemunq field_view get_uint64]]
    ]
    [
        [`string`]
        [
            `boost::string_view` for `field_view`
            
            `std::string` for `field`
        ]
        [`CHAR`, `VARCHAR`, `BINARY`, `VARBINARY`, `TEXT`, `BLOB`...]
        [[refmemunq field_view is_string]]
        [[refmemunq field_view as_string]]
        [[refmemunq field_view get_string]]
    ]
    [
        [`float_`]
        [`float`]
        [`FLOAT`]
        [[refmemunq field_view is_float]]
        [[refmemunq field_view as_float]]
        [[refmemunq field_view get_float]]
    ]
    [
        [`double_`]
        [`double`]
        [`DOUBLE`]
        [[refmemunq field_view is_double]]
        [[refmemunq field_view as_double]]
        [[refmemunq field_view get_double]]
    ]
    [
        [`date`]
        [[reflink date]]
        [`DATE`]
        [[refmemunq field_view is_date]]
        [[refmemunq field_view as_date]]
        [[refmemunq field_view get_date]]
    ]
    [
        [`datetime`]
        [[reflink datetime]]
        [`DATETIME`, `TIMESTAMP`]
        [[refmemunq field_view is_datetime]]
        [[refmemunq field_view as_datetime]]
        [[refmemunq field_view get_datetime]]
    ]
    [
        [`time`]
        [[reflink time]]
        [`TIME`]
        [[refmemunq field_view is_time]]
        [[refmemunq field_view as_time]]
        [[refmemunq field_view get_time]]
    ]
    [
        [`null`]
        []
        [Any of the above, when they're `NULL`]
        [[refmemunq field_view is_null]]
        []
        []
    ]
]

[link mysql.types This section] contains the full reference of type mappings.

[h4 Handling NULL values]

`NULL` values are represented as `field`/`field_view` objects having `kind() == field_kind::null`.
You can check whether a value is `NULL` or not using [refmemunq field_view is_null].
In the following snippet, the `salary` column was defined as a nullable `double`.
This is how `NULL`s are typically handled:

```
    tcp_ssl_resultset result;
    conn.query("SELECT last_name, salary FROM employees", result);

    row r;
    while(result.read_one(r))
    {
        boost::string_view last_name = r.at(0).as_string();
        field_view salary_fv = r.at(1);
        if (salary_fv.is_null())
        {
            // Handle the NULL value
            // Note: salary_fv.is_double() will return false here; NULL is represented as a separate type
            std::cout << "No salary stored for employee " << last_name << std::endl;
        }
        else
        {
            // Handle the non-NULL case. Get the underlying value and use it as you want
            // If there is any schema mismatch (and salary was not defined as DOUBLE), this will throw
            double salary = salary_fv.as_double();

            // Use salary as required
            std::cout << "Employee " << last_name << " earns " << salary << "dollars yearly" << std::endl;
        }
    }
```

[note
    Even though the column was defined as `DOUBLE`, for a `NULL` field, `salary_fv.is_double() == false` and
    `salary_fv.as_double()` will throw an exception. At all effects, `NULL` values are not doubles!     
]



[endsect]

[section:async Asynchronous functions and multi-threading]

The library offers asynchronous versions of each operation involving network transfers.
Following Asio's convention, these are named `async_xxx` (e.g. [refmem connection async_query]).

As mentioned, `connection` holds an internal `Stream` that is used for network transfers.
All network operations involve stream [*reads], stream [*writes], or [*both]. At any given point in time, for
a single connection, [*only one read and one write operation may be outstanding]. Invoking several
reads or writes in parallel for a single connection results in undefined behavior. All network functions
document whether they perform reads, writes or both. Most of them imply both.

For example, [refmem connection query] performs both reads and writes. Doing this is illegal and should be avoided:

```
    // Coroutine body
    // DO NOT DO THIS!!!!
    auto q1 = conn.async_query("SELECT 1", result1, use_awaitable);
    auto q2 = conn.async_query("SELECT 2", result2, use_awaitable);
    co_await (q1 && q2);
```

If you need to perform queries in parallel, open more connections to the server.

[h4 Proxy I/O objects]

`resultset` and `statement` are proxy I/O objects: they use the stream created by the
`connection` to perform the required I/O. This means that [*read and write operations invoked
on resultsets and statements also count toward the `connection` maximum]. This is illegal, too:

```
    // Coroutine body
    // DO NOT DO THIS!!!!
    tcp_ssl_resultset result1, result2;
    rows all_rows;
    co_await conn.async_query("SELECT 1", result1, use_awaitable);

    // Invokes two read operations in parallel - DO NOT DO THIS!!!
    auto query_aw = conn.async_query("SELECT 2", result2, use_awaitable);
    auto read_all_aw = result1.async_read_all(all_rows, use_awaitable);
    co_await (query_aw && read_all_aw);
```

If you're working in a multi-threading environment, please bear in mind that
[*network operations invoked on `statement` and `resultset` also mutate the
`connection`] that created them. Use strands as required to avoid race conditions.

[endsect]

[section:encoding Character sets, collations and time zones]

Encoding: set it on handshake or with SET NAMES and everything you send/receive will be in this encoding.
We don't do any handling. TODO.

[endsect]

[endsect]
