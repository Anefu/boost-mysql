[/
    Copyright (c) 2019-2022 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:overview Overview]
[nochunk]

This section briefly explains the library main classes and functions, and how to use them.
The following diagram shows the interaction between the main classes in the library:

[$mysql/images/class_hierarchy.svg [align center]]

[section:connection Connection objects]

[reflink connection] is the library's "entry point". A connection is an I/O object, templated on
a [reflink Stream] type. A `connection` contains an instance of that `Stream` type and additional state required
by the protocol. To create a `connection`, pass to its constructor the arguments required to construct a `Stream`.

The library defines some typedefs to make things less verbose. The most common one is [reflink tcp_ssl_connection].
In this case, `Stream` is `boost::asio::ssl::stream<boost::asio::ip::tcp::socket>`,
which can be constructed from a `io_context::executor_type` and a `ssl::context`:

```
    boost::asio::io_context ctx;
    boost::asio::ssl::context ssl_ctx(boost::asio::ssl::context::tls_client);
    boost::mysql::tcp_ssl_connection conn(ctx.get_executor(), ssl_ctx);
```

Typedefs for other transports are also available. See [link mysql.other_streams this section] for more info.

The MySQL client/server protocol is session-oriented. Before anything else, you must perform session
establishment, usually by calling [refmem connection connect]. We've already gone through this in the
[link mysql.tutorial tutorial], so we won't repeat it here.

[endsect]

[section:queries_stmts Text queries and prepared statements]

The two main ways to use a connection are text queries and prepared statements:

[table
    [
        [Feature]
        [Used for...]
        [Code]
    ]
    [
        [
            Text queries: [refmem connection query].
        ]
        [
            Simple queries, without parameters:

                * `"START TRANSACTION"`
                * `"SET NAMES utf8"`
                * `"SHOW TABLES"`
            
        ]
        [
            ```
            tcp_ssl_resultset result;
            conn.query("START TRANSACTION", result);
            ```
        ]
    ]
    [
        [
            Prepared statements: [refmem connection prepare_statement], [refmem statement execute].
        ]
        [
            Queries with parameters unknown at compile-time.
        ]
        [
            ```
            tcp_ssl_connection conn;
            conn.connect(/* server host, password... */);

            tcp_ssl_statement stmt;
            conn.prepare_statement("SELECT first_name FROM employees WHERE company_id = ? AND salary > ?");

            tcp_ssl_resultset result;
            stmt.execute(std::make_tuple("HGS", 30000), result);
            ```
        ]
    ]
]

[reflink tcp_ssl_resultset] is a helper typedef for [reflink resultset]. Resultset objects
represent the result of a query or statement execution. They hold auxiliar information
about the operation, but don't contain the actual data generated by the operation.
The next sections show how to obtain it.

[reflink tcp_ssl_statement] is a helper typedef for [reflink statement], which represent
server-side prepared statements, as we've seen.

[endsect]

[section:rows_fields Rows and fields]

Values retrieved from SQL queries are represented as variant-like objects called fields.
Fields are organized in rows. This library defines the following types to represent fields and rows:

[variablelist
    [
        [[reflink field]]
        [The smallest unit of data. A single "cell" in a MySQL table. This is an owning, variant-like type.]
    ]
    [
        [[reflink field_view]]
        [Like `field`, but non-owning.]
    ]
    [
        [[reflink row]]
        [An owning, `vector`-like collection of fields.]
    ]
    [
        [[reflink row_view]]
        [Like `row`, but non-owning.]
    ]
    [
        [[reflink rows]]
        [An owning, matrix-like collection of fields. Represents several rows of the same size in an optimized way.]
    ]
    [
        [[reflink rows_view]]
        [Like `rows`, but non-owning.]
    ]
]

[endsect]

[section Reading rows]

There are three methods to read rows from a `resultset`:

[variablelist
    [
        [[refmem resultset read_one]]
        [Reads rows one by one.]
    ]
    [
        [[refmem resultset read_all]]
        [Reads all rows at once.]
    ]
    [
        [[refmem resultset read_some]]
        [Reads rows in batches of unspecified size.]
    ]
]

For each method, there is an "owning" version, which populates [reflink row] or [reflink rows]
objects by lvalue reference; and a "non-owning" version, which returns [reflink row_view]
or [reflink rows_view] objects, pointing to the `connection` internal buffers.
These view objects are valid until you perform the next operation involving network
transfers on the connection.

The following table shows the most used methods. For a full reference, see
[link mysql.reading_rows this section].

[table
    [
        [Function]
        [Typical use]
        [Use when...]
    ]
    [
        [
            [refmem resultset read_one], owning
        ]
        [
            ```
            row r;
            while (result.read_one(r))
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * [*By default], for resultsets of arbitrary size.
            * When processing one row at a time is preferred.
            * A good alternative to [refmem resultset read_all], when all rows may not fit in memory.
        ]
    ]
    [
        [
            [refmem resultset read_all], owning
        ]
        [
            ```
            rows all_rows;
            result.read_all(all_rows);
            for (row_view r: all_rows)
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * [*By default], for small resultsets.
            * When having all rows at the same time in memory is advantageous.
        ]
    ]
    [
        [
            [refmem resultset read_some], non-owning
        ]
        [
            ```
            while (!result.complete())
            {
                rows_view row_batch = result.read_some(use_views);

                for (row_view r: row_batch)
                {
                    // Process r as required
                    std::cout << r << std::endl;
                }
            }
            ```
        ]
        [
            * [*By default], when efficiency is key.
            * There will be no server interaction that may invalidate the view while you process it.
        ]
    ]
]

In the above snippets, we use [refmem resultset complete] to check whether there are more rows or not.
We say a `resultset` is complete when there are no more rows to read. The server indicates this by sending
us a special packet ("EOF packet" in MySQL slang). After a `resultset` is `complete`, you can access some
additional information about the query execution, like [refmem resultset last_insert_id]
and [refmem resultset affected_rows].

TODO: warn about "you must fully read the entire resultset"

[endsect]

[section Using rows and fields]

All row types support random access iterators, as well as `at` and `operator[]` with the usual semantics.

When iterating or indexing a [reflink row] object, you obtain a [reflink field_view], which is an object
with reference semantics, pointing into `row`'s storage. You can "persist" a `field_view` by constructing a
[reflink field] from it.

```
    tcp_ssl_resultset result;
    row r;

    conn.query("SELECT \"abc\", 42", result);
    result.read_one(r);
    field_view ref = r[0]; // ref points to the string "abc", references r
    field f (ref); // f contains the string "abc"
```

Indexing or iterating a `row_view` also yields `field_view`s. Similarly, indexing
or iterating [reflink rows] or [reflink rows_view] objects yields a `row_view`.

Both `field` and `field_view` are specialized variant-like types that can hold any type
you may find in a MySQL table. The following accessor operations are supported:

* You can query a field's type by using [reflink2 field_view.kind kind],
  which returns a [reflink field_kind] enum. You can query whether a field.
* You can query whether a field contains a certain type with `field::is_xxx`.
* You can get the underlying value with `field::as_xxx` and `field::get_xxx`.
  The `as_xxx` functions are checked (they will throw an exception if the
  actual type doesn't match), while the `get_xxx` are unchecked (they result
  in undefined behavior on type mismatch).
* You can stream and compare fields for equality.

Some examples:

```
    tcp_ssl_resultset result;
    row r;

    conn.query("SELECT \"abc\", 42", result);
    result.read_one(r);

    field_view f = r[0]; // ref points to the string "abc", references r
    if (f.is_string())
    {
        // we know it's a string, unchecked access
        boost::string_view s = f.get_string();
        std::cout << s << std::endl;
    }
    else
    {
        // Oops, something went wrong - schema msimatch?
    }

    // Checked access. Throws if f doesn't contain an int
    f = r[1];
    std::int64_t value = f.as_int64();
    std::cout << value << std::endl;
```

The following table shows the mapping from MySQL types to C++ types:

[table
    [
        [`field_kind`]
        [C++ type]
        [MySQL types]
        [`is` accessor]
        [`as` accessor]
        [`get` accessor]
    ]
    [
        [`int64`]
        [`std::int64_t`]
        [Signed `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`, `YEAR`, `BIT`]
        [[refmemunq field_view is_int64]]
        [[refmemunq field_view as_int64]]
        [[refmemunq field_view get_int64]]
    ]
    [
        [`uint64`]
        [`std::uint64_t`]
        [Unsigned `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`]
        [[refmemunq field_view is_uint64]]
        [[refmemunq field_view as_uint64]]
        [[refmemunq field_view get_uint64]]
    ]
    [
        [`string`]
        [
            `boost::string_view` for `field_view`
            `std::string` for `field`
        ]
        [`CHAR`, `VARCHAR`, `BINARY`, `VARBINARY`, `TEXT`, `BLOB`...]
        [[refmemunq field_view is_string]]
        [[refmemunq field_view as_string]]
        [[refmemunq field_view get_string]]
    ]
    [
        [`float_`]
        [`float`]
        [`FLOAT`]
        [[refmemunq field_view is_float]]
        [[refmemunq field_view as_float]]
        [[refmemunq field_view get_float]]
    ]
    [
        [`double_`]
        [`double`]
        [`DOUBLE`]
        [[refmemunq field_view is_double]]
        [[refmemunq field_view as_double]]
        [[refmemunq field_view get_double]]
    ]
    [
        [`date`]
        [[reflink date]]
        [`DATE`]
        [[refmemunq field_view is_date]]
        [[refmemunq field_view as_date]]
        [[refmemunq field_view get_date]]
    ]
    [
        [`datetime`]
        [[reflink datetime]]
        [`DATETIME`, `TIMESTAMP`]
        [[refmemunq field_view is_datetime]]
        [[refmemunq field_view as_datetime]]
        [[refmemunq field_view get_datetime]]
    ]
    [
        [`time`]
        [[reflink time]]
        [`TIME`]
        [[refmemunq field_view is_time]]
        [[refmemunq field_view as_time]]
        [[refmemunq field_view get_time]]
    ]
    [
        [`null`]
        []
        [Any of the above, when they're `NULL`]
        [[refmemunq field_view is_null]]
        []
        []
    ]
]

TODO: how to handle NULL values correctly

See [link mysql.types this section] for more info on this topic.

[endsect]

[section:async Asynchronous functions]

Async: there are sync with err, exc, async and async with error_info. All operations may imply reads, writes, or both.
You can't call operations that imply reads and writes concurrently. At the moment, most ops are both, so one async at a time.
All operations end up modifying the Stream state, so not thread-safe, use strands.

In all cases, communication will happen over the Stream contained in connection, even if the operation
is called on resultset or statement. Relevant for lifetimes and threading.

Resultset and statements are proxy I/O objects: they use the stream created by the
`connection` to perform the required I/O. This means that they're also templates.
Typedefs like [reflink tcp_ssl_resultset] and [reflink tcp_ssl_statement] exist for simplicity.

All I/O operations involve stream reads, stream writes, or both. At any given point in time, for
a single connection, only one read and one write operation may be outstanding. Invoking several
reads or writes in parallel for a single connection results in undefined behavior. Note that
operations on `resultset`s and `statement`s count towards this limit, too.

The MySQL protocol is a half-duplex request/reply protocol that has the concept of "operations".
This library models some operations as single functions (e.g. connection prepare_statement),
and splits other operations into several calls (e.g. connection query + resultset
read_all), to provide more flexibility. Once you engage in a multi-function operation, you must
complete it (e.g. by calling `resultset::read_xxx` until all rows have been read) before engaging
into the next one. Failing to do so will produce network packet mismatches, resulting in
unspecified behavior. More information [link mysql.async.sequencing here].

[endsect]

[section:encoding Character sets, collations and time zones]

Encoding: set it on handshake or with SET NAMES and everything you send/receive will be in this encoding.
We don't do any handling.

[endsect]

[section:errors Error recovery]

Error recovery: after any server error, you can still use the connection. After a client or network error, close/reopen. In the common case
of ssl streams, delete the object and create it again.

Beware of errors + leaving incomplete results

[endsect]


[endsect]
