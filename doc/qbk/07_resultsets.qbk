[/
    Copyright (c) 2019-2022 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:resultsets Resultsets]
[nochunk]

[reflink2 resultset Resultset objects] represent the result of a SQL query.
You can obtain a `resultset` by executing a [link mysql.queries text query]
or a [link mysql.prepared_statements prepared statement].

A `resultset` contains metadata and state about the query or statement being
executed, but not the actual rows.

[section:read Reading rows]

Recall the following points from [link mysql.overview.read this section]:

* [reflink row] and [reflink row_view] represent a single row, as a collection of fields.
  The first one is owning, and the second one is not.
* [reflink rows] and [reflink rows_view] represent several rows of the same size.
* There are three methods to read rows:
    * [refmem resultset read_one] reads a single row.
    * [refmem resultset read_some] reads a batch of an unspecified size.
    * [refmem resultset read_all] reads all rows at once.
* Each method provides two overloads:
    * An "owning" overload, which populates a [reflink row] or [reflink rows] by lvalue reference.
    * A "view" overload (taking a [reflink use_views_t] placeholder), which returns views into internal buffers.
* You can use [refmem resultset complete] to check whether we've read all rows for this resultset or not.

This yields 6 different methods to retrieve rows. The following table shows them all:


[table
    [
        [Function]
        [Typical use]
        [Use when...]
    ]
    [
        [
            [refmem resultset read_one], owning
        ]
        [
            ```
            row r;
            while (result.read_one(r))
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * [*By default], for resultsets of arbitrary size.
            * When processing one row at a time is preferred.
            * A good alternative to [refmem resultset read_all], when all rows may not fit in memory.
        ]
    ]
    [
        [
            [refmem resultset read_all], owning
        ]
        [
            ```
            rows all_rows;
            result.read_all(all_rows);
            for (row_view r: all_rows)
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * [*By default], for small resultsets.
            * When having all rows at the same time in memory is advantageous.
        ]
    ]
    [
        [
            [refmem resultset read_some], owning
        ]
        [
            ```
            rows row_batch;
            while (!result.complete())
            {
                result.read_some(row_batch);

                for (row_view r: row_batch)
                {
                    // Process r as required
                    std::cout << r << std::endl;
                }
            }
            ```
        ]
        [
            * When efficiency is key.
            * You can't use the non-owning version of `read_some` because of view validity issues
              (more common in its async form). 
        ]
    ]
    [
        [
            [refmem resultset read_one], non-owning
        ]
        [
            ```
            while (true)
            {
                row_view r = result.read_one(use_views);
                if (result.complete())
                    break;

                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * When efficiency is important.
            * When processing one row at a time is preferred.
            * There will be no server interaction that may invalidate the view while you process it.
        ]
    ]
    [
        [
            [refmem resultset read_all], non-owning
        ]
        [
            ```
            rows_view all_rows = result.read_all(use_views);
            for (row_view r: all_rows)
            {
                // Process r as required
                std::cout << r << std::endl;
            }
            ```
        ]
        [
            * When efficiency is important.
            * The resultset is small, as it must fit in memory.
            * Having all rows at the same time in memory is advantageous.
            * There will be no server interaction that may invalidate the view while you process it.
        ]
    ]
    [
        [
            [refmem resultset read_some], non-owning
        ]
        [
            ```
            while (!result.complete())
            {
                rows_view row_batch = result.read_some(use_views);

                for (row_view r: row_batch)
                {
                    // Process r as required
                    std::cout << r << std::endl;
                }
            }
            ```
        ]
        [
            * [*By default], when efficiency is key.
            * There will be no server interaction that may invalidate the view while you process it.
        ]
    ]
]

Some additional guidelines to help you choose between methods:

* If you don't need maximum efficiency, and your resultset is small,
  use the [*owning] version of `read_all`. Note that this doesn't mean
  `read_all` is inefficient, as all functions have been optimized for maximum memory re-use.
* If you don't need maximum efficiency, and your resultset is really big (e.g. all rows wouldn't fit in memory),
  use the [*owning] version of `read_one`.
* If your resultset contains very, very long strings, use any of the [*non-owning] functions, which
  avoid some copying.
* If you need maximum efficiency, use the [*non-owning] version of `read_some`.
* If you need to keep your data valid between operations (e.g. you get a batch of rows,
  and send them through an HTTP link while you get the next batch of rows), use any of the [*owning] methods.
* Measure before making efficiency-related decisions, and try to keep it simple!

[heading Lifetimes]

If you read with an "owning" function, you get a [reflink row] or [reflink rows] object.
These classes have value semantics, and are guaranteed to be valid even after the resultset
that read them is destroyed.

Any view type you obtain from a `row` or `rows` is valid until the owning object is destroyed
or assigned to (similarly to how references to elements in a `vector` work):

```
    rows all_rows;

    // Populate it
    tcp_ssl_resultset result;
    conn.query("SELECT 1", result);
    result.read_all(all_rows);

    // rv references all_rows; valid until all_rows is destroyed
    row_view rv = all_rows.at(0);

    // fv references all_rows, too; same ownership rules
    field_view fv = rv[0];

    // Replace the original all_rows object.
    // Views referencing all_rows are invalidated
    conn.query("SELECT 1", result);
    result.read_all(all_rows);

    // Do NOT use rv or fv here - dangling views
```

Note that both `row` and `rows` [*are immutable types] (in that they don't have mutating functions other than assignment).
They are designed to maximize memory re-use when reading rows. If you need to mutate a row, you can use [refmem row as_vector]
or [refmem row_view as_vector] to obtain a `std::vector<field>`.

If you read with a "non-owning" function, the returned view points into the underlying
`connection` internal read buffer. This means that [*any operation implying a stream read]
on the `connection` or associated `statement` and `resultset` objects invalidates the view.
For example:

```
    tcp_ssl_resultset result1, result2;
    
    // Issue the first query
    conn.query("SELECT 1", result1);

    // Get all the rows, as a view. all_rows points into
    // conn's internal buffers
    rows_view all_rows = result1.read_all(use_views);

    // Issue the second query. A query implies a read operation
    // on the underlying stream, so this line
    // INVALIDATES all_rows!
    conn.query("SELECT 2", result2);

    // Do NOT use all_rows here - dangling view!!
```

[heading More on read_some]

To properly understand `read_one`, we need to know that every [reflink connection]
owns an internal *read buffer*, where packets sent by the server are stored.
It is a single, flat buffer, and you can configure its initial size using
[refmem handshake_params buffer_config] when establishing the connection.
The read buffer may be grown under certain circumstances to accomodate large messages.

`read_some` gets the maximum number of rows that fit in the read buffer (without growing it)
performing a single `read_some` operation on the stream (or using cached data).
If there are rows to read, `read_some` guarantees to read at least one. This means that,
if doing what we described yields no rows (e.g. because of a large row that doesn't fit
into the read buffer), `read_one` will grow the buffer or perform more reads until at least
one row has been read.

If you want to get the most of `read_some`, customize the initial read buffer size
to maximize the number of rows that each batch retrieves.

[endsect]

[section:complete Resultsets becoming complete]

When you have read every single row in a [reflink resultset],
then we say the resultset is [*complete]. You can query for this
fact calling [refmem resultset complete].

If a resultset comes from a SQL statement that generates rows
(e.g. a `SELECT` statement that matches some rows), it completes
the first time you try to read a row, but there are not any more available.
For example, in a resultset with 4 rows, any of the following actions will
complete the resultset:

* Calling [refmem resultset read_one] 5 times.
* Calling [refmem resultset read_all].

If the SQL statement did not generate any rows, we say that the resultset
is [*empty]. This happens for `UPDATE` or `INSERT` statements. Empty resultsets
are complete from the beginning: you don't need to
call [refmem resultset read_one] to make them complete.

After a [reflink resultset] is complete, some extra information about
the query becomes available, like [refmem resultset warning_count]
or [refmem resultset affected_rows]. MySQL sends this information
as an extra packet only after sending every single resultset row,
hence this mechanic.

Calling any row-reading function on a complete resultset is well defined
and has the expected effects.

[endsect]

[section:multifunction Multi-function operations]

Resultsets are generated by multi-function operations like [refmem connection query]
or [refmem statement execute]. These operations will send the execution request to the server.
The server then sends an initial response and all the generated rows.
`query()` and `execute()` will just read the initial response, and not the rows.

This means that the rows will be waiting in the client's read buffer, and must be read
before engaging in further operations. Once you get a `resultset`,
[*you must read all the generated rows], until [refmem resultset complete]
returns `true`. If you start any other operation involving a read before doing this,
you will get packet mismatches and undefined results.

[endsect]

[section:metadata Metadata]

Resultset objects hold metadata describing the columns they
contain. You can access these data using [refmem resultset meta].
This function returns a collection of [reflink metadata]
objects. There is one object for each column retrieved by the SQL query,
and in the same order as in the query. You can find a bunch
of useful information in this object, like the column name,
its type, whether it's a key or not, and so on.

Metadata is always available (i.e. you don't need [refmem resultset complete]
to return `true` before accessing it). For empty resultsets, [refmem resultset meta]
returns an empty collection.

[endsect]

[endsect]